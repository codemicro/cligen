package gen

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/codemicro/cligen/internal/parse"
	"go/format"
	"math/rand"
	"strconv"
	"strings"
	"unicode"
)

var (
	usedIds  = make(map[string]struct{})
	replacer = strings.NewReplacer(
		"0", "a",
		"1", "b",
		"2", "c",
		"3", "d",
		"4", "e",
		"5", "f",
		"6", "g",
		"7", "h",
		"8", "i",
		"9", "j",
		"A", "k",
		"B", "l",
		"C", "m",
		"D", "n",
		"E", "o",
		"F", "p",
	)
	rng = rand.New(rand.NewSource(45986749679038456)) // so the same IDs always appear in the same sequence
)

func nextIdentifier(exported ...bool) string {
	alreadyInUse := true
	var x string
	for alreadyInUse {

		x = replacer.Replace(strconv.FormatInt(rng.Int63n(100000), 16)) // ensure string has no digits in it

		transformFunc := unicode.ToLower
		if len(exported) > 0 && exported[0] {
			transformFunc = unicode.ToUpper
		}

		x = string(transformFunc(rune(x[0]))) + x[1:]
		_, alreadyInUse = usedIds[x]
	}
	return x
}

type generator struct {
	b *bytes.Buffer
}

func newGenerator() *generator {
	return &generator{
		b: new(bytes.Buffer),
	}
}

func (g *generator) w(x string, args ...interface{}) {
	g.b.WriteString(fmt.Sprintf(x, args...) + "\n")
}

func (g *generator) checkPreparationError(cmdName, x string) {
	if x == "" {
		x = "err"
	}
	g.b.WriteString("if " + x + " != nil {\nreturn &preparationError{original: " + x + ", text: " + fmt.Sprintf("%#v", cmdName) + "} \n}\n")
}

func (g *generator) checkRuntimeError(x string) {
	if x == "" {
		x = "err"
	}
	g.b.WriteString("if " + x + " != nil {\nreturn &runtimeError{original: " + x + "} \n}\n")
}

func (g *generator) returnRuntimeError(x string, args ...interface{}) {
	g.b.WriteString("return &runtimeError{original: errors.New(\"" + fmt.Sprintf(x, args...) + "\")}")
}

func (g *generator) returnPreparationError(cmdName, x string, args ...interface{}) {
	g.b.WriteString("return &preparationError{original: errors.New(\"" + fmt.Sprintf(x, args...) + "\"), text: " + fmt.Sprintf("%#v", cmdName) + "}")
}

func File(program *parse.Program) ([]byte, error) {

	helpTexts := makeHelpTexts(program.Functions)

	g := newGenerator()

	g.w("// Code generated by cligen. DO NOT EDIT.")
	g.w("// See https://github.com/codemicro/cligen")

	g.w("")

	g.w("package %s", program.PackageName)

	imports := []string{"errors", "strings", "github.com/codemicro/cligen/parsecli", "math/bits", "strconv", "fmt", "os"}
	g.w("import (")
	for _, i := range imports {
		g.w(`"%s"`, i)
	}
	g.w(")")

	g.w("var intSize = bits.UintSize")
	g.w("var funcNames = map[string]string{")
	g.w(`"help": "help",`)
	for _, finfo := range program.Functions {
		g.w(`%#v: %#v,`, strings.ToLower(finfo.UIName), finfo.UIName)
	}
	g.w("}")

	g.w("var funcHelps = map[string]string{")
	g.w(`"": fmt.Sprintf(%#v, execName),`, helpTexts[""])
	for fname, finfo := range program.Functions {
		g.w("%#v: fmt.Sprintf(%#v, execName),", finfo.UIName, helpTexts[fname])
	}
	g.w("}")

	g.w("var execName = os.Args[0]")

	g.w("type runtimeError struct { original error; text string }")
	g.w("func (err *runtimeError) Error() string { return err.original.Error() }")

	g.w("type preparationError struct { original error; text string }")
	g.w("func (err *preparationError) Error() string { return err.original.Error() }")

	g.w("func Start(input []string) error {")
	{
		g.w("err := run(input)")
		g.w("if err != nil {")
		{
			g.w(`if err, ok := err.(*runtimeError); ok {`)
			{
				g.w("return err")
			}
			g.w("}")

			g.w(`if err, ok := err.(*preparationError); ok {`)
			{
				g.w("x := err.text")
				g.w("if x != \"\" { x = \" \" + x }")
				g.w("fmt.Fprintf(os.Stderr, \"%%s\\nRun `%%s help%%s` for more information\\n\", err.Error(), execName, x)")
				g.w("os.Exit(1)")
				// g.w("return nil")
			}
			g.w("}")
		}
		g.w("}")
		g.w(`return nil`)
	}
	g.w("}")

	g.w("func run(input []string) error {")

	g.w("if len(input) == 0 {")
	g.returnPreparationError("", "not enough arguments")
	g.w("}")

	g.w("var runFunc string")

	g.w(`if fname, ok := funcNames[strings.ToLower(input[0])]; !ok {`)
	g.returnPreparationError("", "no matching targets found")
	g.w("} else {")
	g.w("runFunc = fname")
	g.w("}")

	g.w("parsedFlags, parsedArgs, err := parsecli.Slice(input[1:])")
	g.checkPreparationError("", "")

	g.w("switch runFunc {")

	g.w(`case "help":`)
	{
		g.w("var x string")
		g.w(`if len(parsedArgs) > 0 {`)
		g.w("x = parsedArgs[0]")
		g.w("if x == \"help\" { x = \"\" } else { x = funcNames[x] }")
		g.w("}")
		g.w("fmt.Println(funcHelps[x])")
		g.w("return nil")
	}

	for f, finfo := range program.Functions {

		g.w(`case "%s":`, f)

		checkArgs(g, finfo)
		if err := callFunc(g, finfo); err != nil {
			return nil, err
		}

		g.w("return nil")
	}

	g.w("}")

	g.w("return nil")
	g.w("}")

	fmt.Println(g.b.String())

	return format.Source(g.b.Bytes())
}

func checkArgs(g *generator, f *parse.Function) {

	var numArgs int
	for _, arg := range f.Signature.Argument {
		if !arg.IsPointer {
			numArgs += 1
			continue
		}
	}

	g.w(`if len(parsedArgs) < %d {`, numArgs)
	g.returnPreparationError(f.UIName, "not enough arguments")
	g.w("}")
}

func callFunc(g *generator, f *parse.Function) error {

	var varIDs []string
	var currentArgIndex int

	getSource := func(param *parse.Param) string {
		if param.IsPointer {
			return `parsedFlags["` + param.Name + `"]`
		} else {
			source := fmt.Sprintf("parsedArgs[%d]", currentArgIndex)
			currentArgIndex += 1
			return source
		}
	}

	checkProvided := func(g *generator, param *parse.Param, id string, block []byte) {
		if !param.IsPointer {
			g.b.Write(block)
			return
		}
		g.w(`if _, ok := parsedFlags["%s"]; !ok {`, param.Name)
		g.w("%s = nil", id)
		g.w("} else {")
		g.b.Write(block)
		g.w("}")

	}

	writeVar := func(g *generator, arg *parse.Param, id, t string) {
		var pChar string
		if arg.IsPointer {
			pChar = "*"
		}
		g.w("var %s %s%s", id, pChar, t)
	}

	numConv := func(g *generator, arg *parse.Param, source, id, t string, fx string) {
		writeVar(g, arg, id, t)
		x := newGenerator()
		tempID := nextIdentifier()
		x.w("%s, err := strconv.%s(%s, 10, intSize)", tempID, fx, source)
		x.checkPreparationError(f.UIName, "")

		if arg.IsPointer {
			y := nextIdentifier()
			x.w("%s := %s(%s)", y, t, tempID)
			x.w("%s = &%s", id, y)
		} else {
			x.w("%s = %s(%s)", id, t, tempID)
		}
		checkProvided(g, arg, id, x.b.Bytes())
	}

	for _, arg := range f.Signature.Argument {
		id := nextIdentifier()
		varIDs = append(varIDs, id)

		source := getSource(arg)

		switch arg.Type {
		case "int":
			numConv(g, arg, source, id, "int", "ParseInt")

		case "uint":
			numConv(g, arg, source, id, "uint", "ParseUint")

		case "float32":
			writeVar(g, arg, id, "float32")

			x := newGenerator()

			tempID := nextIdentifier()
			x.w("%s, err := strconv.ParseFloat(%s, 32)", tempID, source)
			x.checkPreparationError(f.UIName, "")

			if arg.IsPointer {
				y := nextIdentifier()
				x.w("%s := float32(%s)", y, tempID)
				x.w("%s = &%s", id, y)
			} else {
				x.w("%s = float32(%s)", id, tempID)
			}

			checkProvided(g, arg, id, x.b.Bytes())

		case "bool":
			writeVar(g, arg, id, "bool")

			x := newGenerator()

			var t string
			if arg.IsPointer {
				t = nextIdentifier()
			} else {
				t = id
			}

			x.w("%s, err := strconv.ParseBool(%s)", t, source)
			x.checkPreparationError(f.UIName, "")

			if arg.IsPointer {
				y := nextIdentifier()
				x.w("%s := %s", y, t)
				x.w("%s = &%s", id, y)
			}

			checkProvided(g, arg, id, x.b.Bytes())

		case "string":
			writeVar(g, arg, id, "string")

			x := newGenerator()

			if arg.IsPointer {
				y := nextIdentifier()
				x.w("%s := %s", y, source)
				x.w("%s = &%s", id, y)
			} else {
				x.w("%s = %s", id, source)
			}

			checkProvided(g, arg, id, x.b.Bytes())
		default:
			return fmt.Errorf("unknown argument data type of %s (%s) in function %s", arg.Type, arg.Name, f.Name)
		}

	}

	var returns []string
	var errID string

	for _, arg := range f.Signature.Return {
		var x string
		if arg.Type == "error" {
			if errID != "" {
				return errors.New("cannot have more than one error return")
			}
			x = nextIdentifier()
			errID = x
		} else {
			x = "_"
		}
		returns = append(returns, x)
	}

	var returnBlock string
	if len(returns) != 0 {
		returnBlock = strings.Join(returns, ", ") + " := "
	}

	g.w("%s%s(%s)", returnBlock, f.Name, strings.Join(varIDs, ", "))

	if len(returns) != 0 {
		g.checkRuntimeError(errID)
	}

	return nil
}

type nameDesc struct{ Name, Description string }

func makeHelpTexts(functions map[string]*parse.Function) map[string]string {
	o := make(map[string]string)
	for functionName, function := range functions {

		var args, flags []string
		var opts []nameDesc
		for _, x := range function.Signature.Argument {

			fx := fmt.Sprintf("[--%s]", x.Name)
			fy := fmt.Sprintf("<%s>", x.Name)

			if x.IsPointer {
				flags = append(flags, fx)
				opts = append(opts, nameDesc{
					Name: x.Name,
				})
			} else {
				args = append(args, fy)
			}
		}

		o[functionName] = helpTextString("%s", function.Description, function.UIName, args, flags, "flags", opts)
	}

	// make overall help text
	var opts []nameDesc
	for _, finfo := range functions {
		opts = append(opts, nameDesc{Name: finfo.UIName, Description: finfo.Description})
	}
	o[""] = helpTextString("%s", "", "<command>", []string{"[<args>]"}, []string{"[<flags>]"}, "commands", opts)

	return o
}

func helpTextString(execName, description, command string, args, flags []string, optName string, opts []nameDesc) string {
	if description != "" {
		description += "\n"
	}

	var optsString string
	if len(opts) != 0 {
		optsString += "Available " + optName + ":\n"
		var x []string
		for _, opt := range opts {
			x = append(x, fmt.Sprintf("    %s  %s", opt.Name, opt.Description))
		}
		optsString += strings.Join(x, "\n")

		optsString = "\n\n" + optsString
	}

	return fmt.Sprintf("%sUsage: %s %s %s %s%s", description, execName, command, strings.Join(flags, " "), strings.Join(args, " "), optsString)
}
